#!/usr/bin/env python3

#
# Copyright 2019-2020 NVIDIA CORPORATION.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#


"""Functions and tools for calculating the accuracy of overlap detection"""

import argparse
from collections import defaultdict

from genomeworks.io import pafio


def points_equal(fixed, point, slop):
    return max(0, int(fixed) - slop) <= int(point) <= (int(fixed) + slop)

def within(val, target, tolerance=0.05):
    return abs(float(val) - float(target)) <= tolerance

def calculate_reciprocal_overlap(record, other):
    q_overlap = min(record.query_end, other.query_end) - max(record.query_start, other.query_start)
    q_total_len = max(record.query_start, other.query_start) - min(record.query_start, other.query_start)

    t_overlap = min(record.target_end, other.target_end) - max(record.target_start, other.target_start)
    t_total_len = max(record.target_end, other.target_end) - min(record.target_start, other.target_start)

    return float(q_overlap + t_overlap) / float(q_total_len + t_total_len)


def _generate_qt_pair_key(record):
    return "_".join(sorted([record.query_sequence_name, record.target_sequence_name]))

def construct_qt_pair_dict(paf_file):
    qt_dict = defaultdict(list)
    score_dict = defaultdict(list)

    for record in pafio.read_paf(paf_file):
        qt_pair = _generate_qt_pair_key(record)
        qt_dict[qt_pair].append(record)
    
    for q in qt_dict:
        score_dict[q] = [False for i in qt_dict[q]]
    return qt_dict, score_dict

def search_record(truth_list, record):
    for t in range(0, len(truth_list)):
        vals = records_equal(record, truth_list[t])
        if vals[0] or vals[1]:
            return t
    return None

def search_qt_pair_dict(truth_qt_dict, score_qt_dict, test_record_file, verbose = False):

    false_positives = 0
    false_negatives = 0
    true_positives = 0
    duplicates = 0
    for rec in pafio.read_paf(test_record_file):
        qt_key = _generate_qt_pair_key(rec)
        if qt_key in truth_qt_dict:
            index = search_record(truth_qt_dict[qt_key], rec)
            if index is None:
                false_positives += 1
                continue

            elif not score_qt_dict[qt_key][index]:
                score_qt_dict[qt_key][index] = True
                true_positives += 1
            else:
                duplicates += 1
        else:
            false_positives += 1

    for qt in score_qt_dict:
        tp = sum(score_qt_dict[qt])
        #true_positives += tp
        false_negatives += len(score_qt_dict[qt]) - tp
        if verbose:
            for i in range(0, len(score_qt_dict[qt])):
                if not score_qt_dict[qt][i]:
                    print("false_negative:", truth_qt_dict[qt][i])

    return true_positives, false_negatives, false_positives, duplicates

def records_equal(record, other, pos_tolerance=100, min_reciprocity=0.8):
    query_start_valid = points_equal(record.query_start, other.query_start, pos_tolerance)
    query_end_valid = points_equal(record.query_end, other.query_end, pos_tolerance)
    target_start_valid = points_equal(record.target_start, other.target_start, pos_tolerance)
    target_end_valid = points_equal(record.target_end, other.target_end, pos_tolerance)

    strands_equal = record.relative_strand == other.relative_strand

    equal = query_start_valid and target_start_valid and query_end_valid and target_end_valid and strands_equal

    reciprocal = calculate_reciprocal_overlap(record, other) >= min_reciprocity

    return equal, reciprocal, query_start_valid, query_end_valid, target_start_valid, target_end_valid, strands_equal

def match_overlaps(record, other, pos_tolerance, min_reciprocal_overlap):
    """Given two sets of query and target ranges, check if the query and target ranges
    fall within a specified tolerance of each other.

    Args:
        query_0 (int, int) : Start/end locations for query_0
        query_1 (int, int) : Start/end locations of query_1
        target_0 (int, int): Start/end location of target_0
        target_1 (int, int): Start/end locations of target_1

    Returns: Boolean indicating query and target match.
    """

    equal, query_start_valid, query_end_valid, target_start_valid, target_end_valid, strands_equal = records_equal(record, other, pos_tolerance)
    pct_recip = calculate_reciprocal_overlap(record, other)
    reciprocal =  pct_recip > min_reciprocal_overlap

    match = equal or reciprocal

    return {"query_start_valid": query_start_valid,
            "query_end_valid": query_end_valid,
            "target_start_valid": target_start_valid,
            "target_end_valid": target_end_valid,
            "reciprocal_overlaps": reciprocal,
            "percent_reciprocal": pct_recip,
            "strands_equal" : strands_equal,
            "equal" : equal,
            "match": match}
    return match

def _swap(val, dest):
    return dest, val

def reverse_record(record):
    query_sequence_name, target_sequence_name = _swap(record.query_sequence_name, record.target_sequence_name)
    query_sequence_length, target_sequence_length = _swap(record.query_sequence_length, record.target_sequence_length)
    query_start, target_start = _swap(record.query_start, record.target_start)
    query_end, target_end = _swap(record.query_end, record.target_end)

    return pafio.Overlap(query_sequence_name, query_sequence_length, query_start, query_end, record.relative_strand, target_sequence_name, target_sequence_length, target_start, target_end, record.num_residue_matches, record.alignment_block_length, record.mapping_quality, record.tags)

def evaluate_paf(truth_paf_filepath, test_paf_filepath, pos_tolerance=200, min_reciprocal=0.8, skip_self_mappings=True, verbose=False):
    """Given a truth and test set PAF file, count number of in/incorrectly detected, and non-detected overlaps
    Args:
       truth_paf_filepath (str): Path to truth set PAF file
       test_paf_filepath (str): Path to test set PAF file
       pos_tolerance (int): query and referennce positions within this range will be connsidered to be a matched overlap
       skip_self_mappings (bool: Skip overlaps where query and target ID are the same

    Returns: 3-tupe consisting of (rue_positive_count, false_positive_count, false_negative_count).
    """

    truth_qt_dict, truth_score_dict = construct_qt_pair_dict(truth_paf_filepath)


    tp, fp, fn, dup = search_qt_pair_dict(truth_qt_dict, truth_score_dict, test_paf_filepath, verbose)
    prec = tp / (tp + fp)
    rec = tp / (tp + fn)

    print(tp, fp, fn, dup, prec, rec)
    return {
        "true_positives" : tp,
        "false_positives" : fp,
        "false_negatives" : fn,
        "duplicates" : dup,
        "precision" : prec,
        "recall" : rec
    }


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Given a truth (reference) and test set of overlaps in PAF format,\
         calculate precision and recall")
    parser.add_argument("-T", "--truth", dest="truth",
                        type=str,
                        default=None, required=True)
    parser.add_argument("-i", "--test", dest="test",
                        type=str,
                        default=None, required=True)
    parser.add_argument("-V", "-verbose", dest="verbose",
        action="store_true", help="Output information for individual records.")
    parser.add_argument("-s", '--slop', dest="pos_tolerance",
                        type=int,
                        default=200,
                        help="Number of basepairs to tolerate on either side of an interval (or record) to consider the two records equal [200].")
    parser.add_argument("-r", "--reciprocal-cutoff", dest="min_reciprocal", type=float,
        required=False, default=0.9, help="Amount of reciprocal overlap required to consider two overlaps the same [0.9]")
    parser.add_argument('--skip_self_mapping',
                        action="store_true",
                        help="Skip checking overlaps where query/target name are same")

    args = parser.parse_args()

    results = evaluate_paf(args.truth, args.test, pos_tolerance=args.pos_tolerance, min_reciprocal=args.min_reciprocal, verbose=args.verbose)
    print("#" + "\t".join(["True_Positives", "False_Positives", "False_Negatives", "Duplicates", "Precision", "Recall"]))
    print("\t".join([str(i) for i in [results["true_positives"], results["false_positives"], results["false_negatives"], results["duplicates"], results["precision"], results["recall"]]]))
    # true_positives, false_positives, false_negatives, incorrect_query_start, incorrect_query_end, incorrect_target_start, \
    #     incorrect_target_end, total_test_records = evaluate_paf(args.truth,
    #                                         args.test,
    #                                         args.pos_tolerance,
    #                                         args.min_reciprocal,
    #                                         args.skip_self_mapping)
    # print("Total test records:", total_test_records)
    # print("True positives: ", true_positives)
    # print("False positives: ", false_positives)
    # print("False negatives: ", false_negatives)
    # print("Incorrect query starts:", incorrect_query_start)
    # print("Incorrect target starts:", incorrect_target_start)
    # print("Incorrect query ends:", incorrect_query_end)
    # print("Incorrect target ends:", incorrect_target_end)

    # precision = true_positives / (true_positives + false_positives)
    # recall = true_positives / (true_positives + false_negatives)

    # print("Precision = {}, Recall = {}".format(precision, recall))
